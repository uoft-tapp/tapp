{"version":3,"sources":["api/constants/index.ts","api/reducers/utils.ts","api/reducers/status.ts","api/reducers/applications.ts","api/reducers/ddahs.ts","views/admin/matching/constants.ts","api/reducers/globals.ts","api/reducers/instructorPreferences.ts","dynamic-entry-router.tsx","views/instructor/store/constants.ts","api/reducers/assignments.ts","api/reducers/sessions.ts","api/reducers/positions.ts","api/reducers/instructors.ts","api/reducers/applicants.ts","api/reducers/contract_templates.ts","api/reducers/postings.ts","api/reducers/posting_positions.ts","api/reducers/users.ts","views/admin/offertable/constants.ts","views/admin/ddah-table/constants.tsx","views/admin/positions/constants.ts","views/admin/offertable/reducers.ts","views/admin/ddah-table/reducers.tsx","views/admin/positions/reducers.ts","views/instructor/store/reducers.ts","views/admin/matching/reducers.ts","rootReducer.ts","store.ts","index.tsx"],"names":["API_INTERACTION_START","API_INTERACTION_END","FETCH_SESSIONS_SUCCESS","FETCH_ONE_SESSION_SUCCESS","UPSERT_ONE_SESSION_SUCCESS","DELETE_ONE_SESSION_SUCCESS","SET_ACTIVE_SESSION","FETCH_INSTRUCTORS_SUCCESS","FETCH_ONE_INSTRUCTOR_SUCCESS","UPSERT_ONE_INSTRUCTOR_SUCCESS","DELETE_ONE_INSTRUCTOR_SUCCESS","FETCH_POSITIONS_SUCCESS","FETCH_ONE_POSITION_SUCCESS","UPSERT_ONE_POSITION_SUCCESS","DELETE_ONE_POSITION_SUCCESS","FETCH_ASSIGNMENTS_SUCCESS","FETCH_ONE_ASSIGNMENT_SUCCESS","UPSERT_ONE_ASSIGNMENT_SUCCESS","DELETE_ONE_ASSIGNMENT_SUCCESS","FETCH_ONE_OFFER_SUCCESS","SET_OFFER_ACCEPTED_SUCCESS","SET_OFFER_REJECTED_SUCCESS","OFFER_CREATE_SUCCESS","OFFER_EMAIL_SUCCESS","OFFER_NAG_SUCCESS","OFFER_WITHDRAW_SUCCESS","FETCH_CONTRACT_TEMPLATES_SUCCESS","FETCH_ONE_CONTRACT_TEMPLATE_SUCCESS","UPSERT_ONE_CONTRACT_TEMPLATE_SUCCESS","DELETE_ONE_CONTRACT_TEMPLATE_SUCCESS","FETCH_ALL_CONTRACT_TEMPLATES_SUCCESS","FETCH_APPLICATIONS_SUCCESS","FETCH_ONE_APPLICATION_SUCCESS","UPSERT_ONE_APPLICATION_SUCCESS","DELETE_ONE_APPLICATION_SUCCESS","FETCH_INSTRUCTOR_PREFERENCES_SUCCESS","FETCH_ONE_INSTRUCTOR_PREFERENCE_SUCCESS","UPSERT_ONE_INSTRUCTOR_PREFERENCE_SUCCESS","DELETE_ONE_INSTRUCTOR_PREFERENCE_SUCCESS","FETCH_WAGE_CHUNKS_FOR_ASSIGNMENT_SUCCESS","UPSERT_WAGE_CHUNKS_FOR_ASSIGNMENT_SUCCESS","FETCH_OFFERS_FOR_ASSIGNMENT_SUCCESS","UPSERT_OFFERS_FOR_ASSIGNMENT_SUCCESS","UPSERT_ONE_WAGE_CHUNK_SUCCESS","DELETE_ONE_WAGE_CHUNK_SUCCESS","FETCH_APPLICANTS_SUCCESS","FETCH_ONE_APPLICANT_SUCCESS","UPSERT_ONE_APPLICANT_SUCCESS","DELETE_ONE_APPLICANT_SUCCESS","FETCH_ACTIVE_USER_SUCCESS","SET_ACTIVE_USER_ROLE_SUCCESS","FETCH_USERS_SUCCESS","UPSERT_USERS_SUCCESS","FETCH_DDAHS_SUCCESS","FETCH_ONE_DDAH_SUCCESS","UPSERT_ONE_DDAH_SUCCESS","DELETE_ONE_DDAH_SUCCESS","DDAH_APPROVE_SUCCESS","DDAH_EMAIL_SUCCESS","FETCH_POSTINGS_SUCCESS","FETCH_ONE_POSTING_SUCCESS","UPSERT_ONE_POSTING_SUCCESS","DELETE_ONE_POSTING_SUCCESS","FETCH_POSTING_POSITIONS_SUCCESS","FETCH_ONE_POSTING_POSITION_SUCCESS","UPSERT_ONE_POSTING_POSITION_SUCCESS","DELETE_ONE_POSTING_POSITION_SUCCESS","SET_GLOBALS","upsertItem","modelData","newItem","didUpdate","newModelData","map","item","id","push","createBasicReducerObject","FETCH_MANY","FETCH_ONE","UPSERT_ONE","DELETE_ONE","state","action","_modelData","payload","deletedItem","filter","createReducer","initialState","handlers","path","_storePath","Math","random","pushToPath","dir","unshift","reducer","_origCreateReducer","_localStoreSelector","localState","e","console","error","createLocalStoreSelector","combineReducers","model","pushToPathCallbacks","Object","entries","newReducer","_origCombineReducers","func","statusReducer","ongoingInteraction","ongoingInteractionsList","i","length","basicReducers","applicationsReducer","ddahsReducer","UPSERT_MATCH","BATCH_UPSERT_MATCHES","UPSERT_GUARANTEE","BATCH_UPSERT_GUARANTEES","UPSERT_NOTE","BATCH_UPSERT_NOTES","SET_SELECTED_MATCHING_POSITION","SET_APPLICANT_VIEW_MODE","SET_UPDATED","globalReducer","position_id","application_id","instructorPreferencesReducer","MainEntry","React","lazy","PublicEntry","DynamicEntryRouter","publicRoute","useRouteMatch","content","Fragment","fallback","SET_INSTRUCTOR_DDAHS_FOR_EMAIL","SET_INSTRUCTOR_ACTIVE_POSITION","setWageChunks","assignmentId","assignment_id","_wageChunksByAssignmentId","setOffers","_offersByAssignmentId","offers","assignmentsReducer","sessionsReducer","activeSession","positionsReducer","instructorsReducer","applicantsReducer","contractTemplatesReducer","all","postingsReducer","posting_id","postingPositionsReducer","usersReducer","users","active_user","active_role","SET_SELECTED_ROWS","SET_SELECTED_DDAH_TABLE_ROWS","SET_SELECTED_POSITION","offerTableReducer","selectedAssignmentIds","ddahsTableReducer","selectedDdahIds","positionsTableReducer","selectedPositionIds","instructorUIReducer","selectedDdahForEmailIds","activePositionId","matchingDataReducer","matches","guarantees","notes","selectedMatchingPositionId","applicantViewMode","updated","existingMatch","find","match","utorid","positionCode","newMatch","stagedHoursAssigned","stagedAssigned","starred","hidden","guarantee","existingNotes","note","status","sessions","positions","applicants","applications","assignments","instructors","contractTemplates","postings","postingPositions","ddahs","instructorPreferences","ui","notifications","notificationReducer","offerTable","ddahsTable","positionsTable","globals","instructor","matchingData","configureStore","persistConfig","key","storage","whitelist","persistedReducer","persistReducer","rootReducer","store","createStore","composeWithDevTools","applyMiddleware","thunk","persistor","persistStore","DevFrame","props","children","FullDevFrame","a","then","module","default","Suspense","render","Component","ReactDOM","document","getElementById","hot","accept","NextApp","require"],"mappings":"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","file":"static/js/main.b48486f3.chunk.js","sourcesContent":["export const API_INTERACTION_START = \"API_INTERACTION_START\";\nexport const API_INTERACTION_END = \"API_INTERACTION_END\";\n\n/* Constants were batch-created with the following code:\n\n    let wrap = x => x.map(y => `export const ${y} = \"${y}\";`);\n    console.log(\n        [\n            \"session\",\n            \"instructor\",\n            \"position\",\n            \"assignment\",\n            \"offer\",\n            \"contract_template\",\n            \"application\",\n            \"wage_chunk\"\n        ]\n            .map(x => {\n                x = x.toUpperCase();\n                return [`// \\`${x.toLowerCase()}\\`-related constants`]\n                    .concat(\n                        wrap([\n                            `FETCH_${x}S_SUCCESS`,\n                            `FETCH_ONE_${x}_SUCCESS`,\n                            `UPSERT_ONE_${x}_SUCCESS`,\n                            `DELETE_ONE_${x}_SUCCESS`\n                        ])\n                    )\n                    .join(\"\\n\");\n            })\n            .join(\"\\n\\n\")\n    );\n*/\n\n// `session`-related constants\nexport const FETCH_SESSIONS_SUCCESS = \"FETCH_SESSIONS_SUCCESS\";\nexport const FETCH_ONE_SESSION_SUCCESS = \"FETCH_ONE_SESSION_SUCCESS\";\nexport const UPSERT_ONE_SESSION_SUCCESS = \"UPSERT_ONE_SESSION_SUCCESS\";\nexport const DELETE_ONE_SESSION_SUCCESS = \"DELETE_ONE_SESSION_SUCCESS\";\nexport const SET_ACTIVE_SESSION = \"SET_ACTIVE_SESSION\";\n\n// `instructor`-related constants\nexport const FETCH_INSTRUCTORS_SUCCESS = \"FETCH_INSTRUCTORS_SUCCESS\";\nexport const FETCH_ONE_INSTRUCTOR_SUCCESS = \"FETCH_ONE_INSTRUCTOR_SUCCESS\";\nexport const UPSERT_ONE_INSTRUCTOR_SUCCESS = \"UPSERT_ONE_INSTRUCTOR_SUCCESS\";\nexport const DELETE_ONE_INSTRUCTOR_SUCCESS = \"DELETE_ONE_INSTRUCTOR_SUCCESS\";\n\n// `position`-related constants\nexport const FETCH_POSITIONS_SUCCESS = \"FETCH_POSITIONS_SUCCESS\";\nexport const FETCH_ONE_POSITION_SUCCESS = \"FETCH_ONE_POSITION_SUCCESS\";\nexport const UPSERT_POSITIONS_SUCCESS = \"UPSERT_POSITIONS_SUCCESS\";\nexport const UPSERT_ONE_POSITION_SUCCESS = \"UPSERT_ONE_POSITION_SUCCESS\";\nexport const DELETE_ONE_POSITION_SUCCESS = \"DELETE_ONE_POSITION_SUCCESS\";\n\n// `assignment`-related constants\nexport const FETCH_ASSIGNMENTS_SUCCESS = \"FETCH_ASSIGNMENTS_SUCCESS\";\nexport const FETCH_ONE_ASSIGNMENT_SUCCESS = \"FETCH_ONE_ASSIGNMENT_SUCCESS\";\nexport const UPSERT_ONE_ASSIGNMENT_SUCCESS = \"UPSERT_ONE_ASSIGNMENT_SUCCESS\";\nexport const DELETE_ONE_ASSIGNMENT_SUCCESS = \"DELETE_ONE_ASSIGNMENT_SUCCESS\";\n\n// `offer`-related constants\nexport const FETCH_OFFERS_SUCCESS = \"FETCH_OFFERS_SUCCESS\";\nexport const FETCH_ONE_OFFER_SUCCESS = \"FETCH_ONE_OFFER_SUCCESS\";\nexport const UPSERT_ONE_OFFER_SUCCESS = \"UPSERT_ONE_OFFER_SUCCESS\";\nexport const DELETE_ONE_OFFER_SUCCESS = \"DELETE_ONE_OFFER_SUCCESS\";\nexport const SET_OFFER_ACCEPTED_SUCCESS = \"SET_OFFER_ACCEPTED_SUCCESS\";\nexport const SET_OFFER_REJECTED_SUCCESS = \"SET_OFFER_REJECTED_SUCCESS\";\nexport const OFFER_CREATE_SUCCESS = \"OFFER_CREATE_SUCCESS\";\nexport const OFFER_EMAIL_SUCCESS = \"OFFER_EMAIL_SUCCESS\";\nexport const OFFER_NAG_SUCCESS = \"OFFER_NAG_SUCCESS\";\nexport const OFFER_WITHDRAW_SUCCESS = \"OFFER_WITHDRAW_SUCCESS\";\n\n// `contract_template`-related constants\nexport const FETCH_CONTRACT_TEMPLATES_SUCCESS =\n    \"FETCH_CONTRACT_TEMPLATES_SUCCESS\";\nexport const FETCH_ONE_CONTRACT_TEMPLATE_SUCCESS =\n    \"FETCH_ONE_CONTRACT_TEMPLATE_SUCCESS\";\nexport const UPSERT_ONE_CONTRACT_TEMPLATE_SUCCESS =\n    \"UPSERT_ONE_CONTRACT_TEMPLATE_SUCCESS\";\nexport const DELETE_ONE_CONTRACT_TEMPLATE_SUCCESS =\n    \"DELETE_ONE_CONTRACT_TEMPLATE_SUCCESS\";\nexport const FETCH_ALL_CONTRACT_TEMPLATES_SUCCESS =\n    \"FETCH_ALL_CONTRACT_TEMPLATES_SUCCESS\";\n\n// `application`-related constants\nexport const FETCH_APPLICATIONS_SUCCESS = \"FETCH_APPLICATIONS_SUCCESS\";\nexport const FETCH_ONE_APPLICATION_SUCCESS = \"FETCH_ONE_APPLICATION_SUCCESS\";\nexport const UPSERT_ONE_APPLICATION_SUCCESS = \"UPSERT_ONE_APPLICATION_SUCCESS\";\nexport const DELETE_ONE_APPLICATION_SUCCESS = \"DELETE_ONE_APPLICATION_SUCCESS\";\n\n// `instructor_preference`-related constants\nexport const FETCH_INSTRUCTOR_PREFERENCES_SUCCESS =\n    \"FETCH_INSTRUCTOR_PREFERENCES_SUCCESS\";\nexport const FETCH_ONE_INSTRUCTOR_PREFERENCE_SUCCESS =\n    \"FETCH_ONE_INSTRUCTOR_PREFERENCE_SUCCESS\";\nexport const UPSERT_ONE_INSTRUCTOR_PREFERENCE_SUCCESS =\n    \"UPSERT_ONE_INSTRUCTOR_PREFERENCE_SUCCESS\";\nexport const DELETE_ONE_INSTRUCTOR_PREFERENCE_SUCCESS =\n    \"DELETE_ONE_INSTRUCTOR_PREFERENCE_SUCCESS\";\n\n// `wage_chunk`-related constants\nexport const FETCH_WAGE_CHUNKS_SUCCESS = \"FETCH_WAGE_CHUNKS_SUCCESS\";\nexport const FETCH_WAGE_CHUNKS_FOR_ASSIGNMENT_SUCCESS =\n    \"FETCH_WAGE_CHUNKS_FOR_ASSIGNMENT_SUCCESS\";\nexport const UPSERT_WAGE_CHUNKS_FOR_ASSIGNMENT_SUCCESS =\n    \"UPSERT_WAGE_CHUNKS_FOR_ASSIGNMENT_SUCCESS\";\nexport const FETCH_OFFERS_FOR_ASSIGNMENT_SUCCESS =\n    \"FETCH_OFFERS_FOR_ASSIGNMENT_SUCCESS\";\nexport const UPSERT_OFFERS_FOR_ASSIGNMENT_SUCCESS =\n    \"UPSERT_OFFERS_FOR_ASSIGNMENT_SUCCESS\";\nexport const FETCH_ONE_WAGE_CHUNK_SUCCESS = \"FETCH_ONE_WAGE_CHUNK_SUCCESS\";\nexport const UPSERT_ONE_WAGE_CHUNK_SUCCESS = \"UPSERT_ONE_WAGE_CHUNK_SUCCESS\";\nexport const DELETE_ONE_WAGE_CHUNK_SUCCESS = \"DELETE_ONE_WAGE_CHUNK_SUCCESS\";\n\n// `applicant`-related constants\nexport const FETCH_APPLICANTS_SUCCESS = \"FETCH_APPLICANTS_SUCCESS\";\nexport const FETCH_ONE_APPLICANT_SUCCESS = \"FETCH_ONE_APPLICANT_SUCCESS\";\nexport const UPSERT_ONE_APPLICANT_SUCCESS = \"UPSERT_ONE_APPLICANT_SUCCESS\";\nexport const DELETE_ONE_APPLICANT_SUCCESS = \"DELETE_ONE_APPLICANT_SUCCESS\";\n\n// `user`/`active_user` constants\nexport const FETCH_ACTIVE_USER_SUCCESS = \"FETCH_ACTIVE_USER_SUCCESS\";\nexport const SET_ACTIVE_USER_ROLE_SUCCESS = \"SET_ACTIVE_USER_ROLE_SUCCESS\";\nexport const FETCH_USERS_SUCCESS = \"FETCH_USERS_SUCCESS\";\nexport const UPSERT_USERS_SUCCESS = \"UPSERT_USERS_SUCCESS\";\n\n// `ddah`-related constants\nexport const FETCH_DDAHS_SUCCESS = \"FETCH_DDAHS_SUCCESS\";\nexport const FETCH_ONE_DDAH_SUCCESS = \"FETCH_ONE_DDAH_SUCCESS\";\nexport const UPSERT_ONE_DDAH_SUCCESS = \"UPSERT_ONE_DDAH_SUCCESS\";\nexport const DELETE_ONE_DDAH_SUCCESS = \"DELETE_ONE_DDAH_SUCCESS\";\nexport const DDAH_APPROVE_SUCCESS = \"DDAH_APPROVE_SUCCESS\";\nexport const DDAH_EMAIL_SUCCESS = \"DDAH_EMAIL_SUCCESS\";\nexport const DDAH_ACCEPT_SUCCESS = \"DDAH_ACCEPT_SUCCESS\";\nexport const DDAH_REJECT_SUCCESS = \"DDAH_REJECT_SUCCESS\";\n\n// `posting`-related constants\nexport const FETCH_POSTINGS_SUCCESS = \"FETCH_POSTINGS_SUCCESS\";\nexport const FETCH_ONE_POSTING_SUCCESS = \"FETCH_ONE_POSTING_SUCCESS\";\nexport const UPSERT_ONE_POSTING_SUCCESS = \"UPSERT_ONE_POSTING_SUCCESS\";\nexport const DELETE_ONE_POSTING_SUCCESS = \"DELETE_ONE_POSTING_SUCCESS\";\n\n// `posting_position`-related constants\nexport const FETCH_POSTING_POSITIONS_SUCCESS =\n    \"FETCH_POSTING_POSITIONS_SUCCESS\";\nexport const FETCH_ONE_POSTING_POSITION_SUCCESS =\n    \"FETCH_ONE_POSTING_POSITION_SUCCESS\";\nexport const UPSERT_ONE_POSTING_POSITION_SUCCESS =\n    \"UPSERT_ONE_POSTING_POSITION_SUCCESS\";\nexport const DELETE_ONE_POSTING_POSITION_SUCCESS =\n    \"DELETE_ONE_POSTING_POSITION_SUCCESS\";\n\n// `debug` constants\nexport const DEBUG_SET_ACTIVE_USER_SUCCESS = \"DEBUG_SET_ACTIVE_USER_SUCCESS\";\n\n// global constants\nexport const SET_GLOBALS = \"SET_GLOBALS\";\n","/*\n * A set of utility functions to help with creating reducers\n */\n\nimport { combineReducers as _origCombineReducers } from \"redux\";\nimport { createReducer as _origCreateReducer } from \"redux-create-reducer\";\nimport type { Action, AnyAction, Reducer } from \"redux\";\nimport type { Selector } from \"reselect\";\n\ntype HasIdField = { id: number };\nexport interface HasPayload<T> extends AnyAction {\n    payload: T;\n}\n//export type HasPayload<T> = { payload: T } & AnyAction;\nexport type BasicState<T> = { _modelData: T[] };\nexport type TaggedState<T> = BasicState<T> & { _storePath: _StorePath };\ntype Handlers<State> = {\n    [key: string]: (state: State, action: any) => State;\n};\n\ntype _StorePath = {\n    id: number;\n    path: (string | number)[];\n};\ninterface _StorePathWithPushToPath extends _StorePath {\n    pushToPath: (dir: string | number) => void;\n}\ninterface TaggedReducer<State, A extends Action = AnyAction>\n    extends Reducer<State, A> {\n    _storePath: _StorePathWithPushToPath;\n}\n\ninterface TaggedReducerWithSelector<State> extends TaggedReducer<State> {\n    _localStoreSelector: Selector<any, State>;\n}\n\ntype TaggedReducersMapObject<State, A extends Action = AnyAction> = {\n    [K in keyof State & string]: TaggedReducer<State[K], A>;\n};\n\n/**\n * Either updates the item `modelData`\n * with id == newItem.id, or appends it.\n *\n * @returns {object} An updated version of modelData\n */\nexport function upsertItem<T extends HasIdField>(\n    modelData: T[],\n    newItem: T\n): T[] {\n    let didUpdate = false;\n    const newModelData = modelData.map((item) => {\n        if (item.id === newItem.id) {\n            didUpdate = true;\n            return newItem;\n        }\n        return item;\n    });\n    if (!didUpdate) {\n        newModelData.push(newItem);\n    }\n    return newModelData;\n}\n\n/**\n * Create a basic reducer for the operations\n *   FETCH_MANY\n *   FETCH_ONE\n *   UPSERT_ONE\n *   DELETE_ONE\n * A basic reducer assumes that `state._modelData` is\n * an array and that each item in that array has an `id`\n * that can be used to determine upserts and deletes, etc..\n *\n * @returns An object of reducers suitable for passing to `createReducer`\n */\nexport function createBasicReducerObject<T extends HasIdField>(\n    FETCH_MANY: string,\n    FETCH_ONE: string,\n    UPSERT_ONE: string,\n    DELETE_ONE: string\n) {\n    return {\n        [FETCH_MANY]: (state: BasicState<T>, action: HasPayload<T[]>) => ({\n            ...state,\n            _modelData: action.payload,\n        }),\n        [FETCH_ONE]: (state: BasicState<T>, action: HasPayload<T>) => ({\n            ...state,\n            _modelData: upsertItem(state._modelData, action.payload),\n        }),\n        [UPSERT_ONE]: (state: BasicState<T>, action: HasPayload<T>) => ({\n            ...state,\n            _modelData: upsertItem(state._modelData, action.payload),\n        }),\n        [DELETE_ONE]: (state: BasicState<T>, action: HasPayload<T>) => {\n            const deletedItem = action.payload;\n            return {\n                ...state,\n                _modelData: state._modelData.filter(\n                    (item) => item.id !== deletedItem.id\n                ),\n            };\n        },\n    };\n}\n\n/**\n * Wraps \"redux-create-reducer\"'s version of `createReducer` to add\n * a `_storePath` attribute to the initial state and the reducer.\n * `_storePath` is used by `localStoreSelector` to return the local\n * state when passed in the global state. (For example, if\n *    `state = { a: b: localState }`, then `localStoreSelector(state) === localState`.)\n *\n * @param {object} initialState\n * @param {object} handlers\n * @returns\n */\nexport function createReducer<State>(\n    initialState: State,\n    handlers: Handlers<State>\n) {\n    const path: (string | number)[] = [];\n    function pushToPath(dir: string | number) {\n        path.unshift(dir);\n    }\n    // Every isolated state should have a unique id, so generate\n    // a random one.\n    const _storePath: _StorePathWithPushToPath = {\n        id: Math.random(),\n        path,\n        pushToPath,\n    };\n\n    // add _storePath to the initial state and to the\n    // new reducer\n    (initialState as unknown as TaggedState<unknown>)._storePath = _storePath;\n    const reducer = _origCreateReducer(\n        initialState,\n        handlers as any\n    ) as TaggedReducerWithSelector<typeof initialState>;\n    reducer._storePath = _storePath;\n\n    // For convenience, attach a local store selector to the reducer\n    reducer._localStoreSelector = createLocalStoreSelector<State>(\n        _storePath\n    ) as unknown as Selector<State, State>;\n\n    return reducer;\n}\n\n/**\n * Search `state` for a local state in the location of `_storePath.path`.\n * For example, if `_storePath.path = [\"a\", \"b\"]`, this function will\n * return `state.a.b`.\n *\n * @param {object} state Redux state\n * @param {object} _storePath The `_storePath` object to use for searching `state`\n * @returns\n */\nfunction _localStoreSelector<T>(\n    state: TaggedState<T> | any,\n    _storePath: _StorePath\n): TaggedState<T> {\n    if (state._storePath && state._storePath.id === _storePath.id) {\n        return state;\n    }\n    try {\n        let localState = state;\n        for (const dir of _storePath.path) {\n            localState = localState[dir];\n        }\n        return localState;\n    } catch (e: any) {\n        // eslint-disable-next-line\n        console.error(\n            \"Searching\",\n            state,\n            \"for local state with path\",\n            _storePath,\n            \"but encountered an error\"\n        );\n    }\n    return state;\n}\n\n/**\n * Create a selector that, when passed in the global redux state, will search\n * and return a local state based on the information in `_storePath`. This selector\n * can be passed either the local state or the global state. If it is passed the local\n * state, it checks that the `state._storePath.id` field matches `_storePath.id`;\n * if so, this selector immediately returns `state`. Otherwise, use `_storePath.path`\n * to search for the local state. For example, if `_storePath.path = [\"a\", \"b\"]`,\n * the returned selector will return `state.a.b`.\n *\n * @export\n * @param _storePath\n * @param _storePath.path The path to search in the redux state\n * @param _storePath.id The unique id of the local state\n * @returns {Function} A selector that returns the local state (based on `_storePath`) when passed the global state\n */\nexport function createLocalStoreSelector<T>(_storePath: _StorePath) {\n    return (state: any) => _localStoreSelector<T>(state, _storePath);\n}\n\n/**\n * Wraps \"redux\"'s `combineReducers` function so that `reducer._storePath.pushToPath`\n * is called on all child reducers.\n *\n * Redux's `combineReducers` function creates a new reducer from `model` that dispatches\n * actions to all reducers listed in `model`, but passes them an isolated part of the\n * store instead of passing in the full redux store as `state`. This is great for writing\n * reducers, but it makes things complicated for writing selectors, since, in general,\n * a selector will get passed the whole state, not the isolated part of the state that\n * `combineReducers` supplies. This wrapped version of `combineReducers` adds to a `path`\n * variable that is present in each reducer and which can be passed to a smart selector.\n *\n * @export\n * @param model An object whose values are reducers\n * @returns  A reducer\n */\nexport function combineReducers<T extends TaggedReducersMapObject<S>, S>(\n    model: T\n) {\n    const pushToPathCallbacks: Function[] = [];\n    // recursively call all `pushToPath` functions.\n    // They have been stored in `pushToPathCallbacks`\n    function pushToPath(dir: string) {\n        for (const func of pushToPathCallbacks) {\n            func(dir);\n        }\n    }\n\n    for (const [dir, reducer] of Object.entries(model) as Array<\n        [keyof T & string, TaggedReducer<T>]\n    >) {\n        if (reducer._storePath) {\n            reducer._storePath.pushToPath(dir);\n            pushToPathCallbacks.push(reducer._storePath.pushToPath);\n        }\n    }\n\n    const newReducer = _origCombineReducers(model as any);\n    (newReducer as any)._storePath = { pushToPath };\n\n    return newReducer as unknown as TaggedReducer<{\n        [K in keyof T]: ReturnType<T[K]>;\n    }>;\n}\n","import { createReducer, HasPayload } from \"./utils\";\nimport { API_INTERACTION_START, API_INTERACTION_END } from \"../constants\";\n\ntype Interaction = { id: string; message: string };\ninterface StatusState {\n    ongoingInteraction: boolean;\n    ongoingInteractionsList: Interaction[];\n}\nconst initialState: StatusState = {\n    ongoingInteraction: false,\n    ongoingInteractionsList: [],\n};\n\n// Keep a list of all ongoing interactions that are in progress.\n// This way we could display a spinner or some-such while interactions\n// are going on. Interactions will be mostly network-based interactions.\nexport const statusReducer = createReducer(initialState, {\n    [API_INTERACTION_START]: (state, action: HasPayload<Interaction>) => ({\n        ...state,\n        ongoingInteraction: true,\n        ongoingInteractionsList: [\n            ...state.ongoingInteractionsList,\n            action.payload,\n        ],\n    }),\n    [API_INTERACTION_END]: (state, action: HasPayload<{ id: string }>) => {\n        // remove the current interaction\n        const ongoingInteractionsList = state.ongoingInteractionsList.filter(\n            (i) => i.id !== action.payload.id\n        );\n        return {\n            ...state,\n            ongoingInteraction: ongoingInteractionsList.length > 0,\n            ongoingInteractionsList: ongoingInteractionsList,\n        };\n    },\n});\n","import {\n    FETCH_APPLICATIONS_SUCCESS,\n    FETCH_ONE_APPLICATION_SUCCESS,\n    UPSERT_ONE_APPLICATION_SUCCESS,\n    DELETE_ONE_APPLICATION_SUCCESS,\n} from \"../constants\";\nimport { RawApplication } from \"../defs/types\";\nimport { createBasicReducerObject, createReducer } from \"./utils\";\n\ninterface ApplicationState {\n    _modelData: RawApplication[];\n}\nconst initialState: ApplicationState = {\n    _modelData: [],\n};\n\n// basicReducers is an object whose keys are FETCH_SESSIONS_SUCCESS, etc,\n// and values are the corresponding reducer functions\nconst basicReducers = createBasicReducerObject<RawApplication>(\n    FETCH_APPLICATIONS_SUCCESS,\n    FETCH_ONE_APPLICATION_SUCCESS,\n    UPSERT_ONE_APPLICATION_SUCCESS,\n    DELETE_ONE_APPLICATION_SUCCESS\n);\n\nexport const applicationsReducer = createReducer(initialState, basicReducers);\n","import {\n    FETCH_DDAHS_SUCCESS,\n    FETCH_ONE_DDAH_SUCCESS,\n    UPSERT_ONE_DDAH_SUCCESS,\n    DELETE_ONE_DDAH_SUCCESS,\n} from \"../constants\";\nimport { RawDdah } from \"../defs/types\";\nimport { createBasicReducerObject, createReducer } from \"./utils\";\n\ninterface DdahState {\n    _modelData: RawDdah[];\n}\n\nconst initialState: DdahState = {\n    _modelData: [],\n};\n\n// basicReducers is an object whose keys are FETCH_SESSIONS_SUCCESS, etc,\n// and values are the corresponding reducer functions\nconst basicReducers = createBasicReducerObject<RawDdah>(\n    FETCH_DDAHS_SUCCESS,\n    FETCH_ONE_DDAH_SUCCESS,\n    UPSERT_ONE_DDAH_SUCCESS,\n    DELETE_ONE_DDAH_SUCCESS\n);\n\nexport const ddahsReducer = createReducer(initialState, basicReducers);\n","export const UPSERT_MATCH = \"UPSERT_MATCH\";\nexport const BATCH_UPSERT_MATCHES = \"BATCH_UPSERT_MATCHES\";\nexport const UPSERT_GUARANTEE = \"UPSERT_GUARANTEE\";\nexport const BATCH_UPSERT_GUARANTEES = \"BATCH_UPSERT_GUARANTEES\";\nexport const UPSERT_NOTE = \"UPSERT_NOTE\";\nexport const BATCH_UPSERT_NOTES = \"BATCH_UPSERT_NOTES\";\nexport const SET_SELECTED_MATCHING_POSITION = \"SET_SELECTED_MATCHING_POSITION\";\nexport const SET_APPLICANT_VIEW_MODE = \"SET_APPLICANT_VIEW_MODE\";\nexport const SET_UPDATED = \"SET_UPDATED\";\n","import { createReducer } from \"redux-create-reducer\";\nimport { SET_GLOBALS } from \"../constants\";\n\nexport const globalReducer = createReducer({} as Record<string, string>, {\n    [SET_GLOBALS]: (state, action) => ({\n        ...state,\n        ...action.payload,\n    }),\n});\n","import {\n    FETCH_INSTRUCTOR_PREFERENCES_SUCCESS,\n    FETCH_ONE_INSTRUCTOR_PREFERENCE_SUCCESS,\n    UPSERT_ONE_INSTRUCTOR_PREFERENCE_SUCCESS,\n    DELETE_ONE_INSTRUCTOR_PREFERENCE_SUCCESS,\n} from \"../constants\";\nimport { RawInstructorPreference } from \"../defs/types\";\nimport { createReducer, HasPayload } from \"./utils\";\n\ninterface InstructorPreferenceState {\n    _modelData: RawInstructorPreference[];\n}\nconst initialState: InstructorPreferenceState = {\n    _modelData: [],\n};\n\nfunction upsertItem(\n    modelData: RawInstructorPreference[],\n    newItem: RawInstructorPreference\n): RawInstructorPreference[] {\n    let didUpdate = false;\n    const newModelData = modelData.map((item) => {\n        if (\n            item.position_id === newItem.position_id &&\n            item.application_id === newItem.application_id\n        ) {\n            didUpdate = true;\n            return newItem;\n        }\n        return item;\n    });\n    if (!didUpdate) {\n        newModelData.push(newItem);\n    }\n    return newModelData;\n}\n\n// PositionPostings have no `id` field, but they are uniquely determined\n// by their `position_id` adn `posting_id`. So, we need to create custom\n// reducer functions.\nexport const instructorPreferencesReducer = createReducer(initialState, {\n    [FETCH_INSTRUCTOR_PREFERENCES_SUCCESS]: (\n        state: InstructorPreferenceState,\n        action: HasPayload<RawInstructorPreference[]>\n    ) => ({\n        ...state,\n        _modelData: action.payload,\n    }),\n    [FETCH_ONE_INSTRUCTOR_PREFERENCE_SUCCESS]: (\n        state: InstructorPreferenceState,\n        action: HasPayload<RawInstructorPreference>\n    ) => ({\n        ...state,\n        _modelData: upsertItem(state._modelData, action.payload),\n    }),\n    [UPSERT_ONE_INSTRUCTOR_PREFERENCE_SUCCESS]: (\n        state: InstructorPreferenceState,\n        action: HasPayload<RawInstructorPreference>\n    ) => ({\n        ...state,\n        _modelData: upsertItem(state._modelData, action.payload),\n    }),\n    [DELETE_ONE_INSTRUCTOR_PREFERENCE_SUCCESS]: (\n        state: InstructorPreferenceState,\n        action: HasPayload<RawInstructorPreference>\n    ) => {\n        const deletedItem = action.payload;\n        return {\n            ...state,\n            _modelData: state._modelData.filter(\n                (item) =>\n                    !(\n                        item.position_id === deletedItem.position_id &&\n                        item.application_id === deletedItem.application_id\n                    )\n            ),\n        };\n    },\n});\n","import React, { Suspense } from \"react\";\nimport { useRouteMatch } from \"react-router\";\n\nconst MainEntry = React.lazy(() => import(\"./main-entry\"));\nconst PublicEntry = React.lazy(() => import(\"./public-entry\"));\n\n/**\n * Dynamically load the correct entry component based on the route string.\n *\n * @export\n * @returns\n */\nexport default function DynamicEntryRouter() {\n    const publicRoute = useRouteMatch(\"/public\");\n    let content = <MainEntry />;\n    if (publicRoute) {\n        content = <PublicEntry />;\n    }\n\n    return (\n        <React.Fragment>\n            <Suspense fallback=\"Loading...\">{content}</Suspense>\n        </React.Fragment>\n    );\n}\n","export const SET_INSTRUCTOR_DDAHS_FOR_EMAIL = \"SET_INSTRUCTOR_DDAHS_FOR_EMAIL\";\nexport const SET_INSTRUCTOR_ACTIVE_POSITION = \"SET_INSTRUCTOR_ACTIVE_POSITION\";\n","import {\n    FETCH_ASSIGNMENTS_SUCCESS,\n    FETCH_ONE_ASSIGNMENT_SUCCESS,\n    UPSERT_ONE_ASSIGNMENT_SUCCESS,\n    DELETE_ONE_ASSIGNMENT_SUCCESS,\n    FETCH_WAGE_CHUNKS_FOR_ASSIGNMENT_SUCCESS,\n    UPSERT_WAGE_CHUNKS_FOR_ASSIGNMENT_SUCCESS,\n    FETCH_OFFERS_FOR_ASSIGNMENT_SUCCESS,\n    UPSERT_OFFERS_FOR_ASSIGNMENT_SUCCESS,\n} from \"../constants\";\nimport { RawAssignment, RawOffer, RawWageChunk } from \"../defs/types\";\nimport { createBasicReducerObject, createReducer, HasPayload } from \"./utils\";\n\ninterface AssignmentState {\n    _modelData: RawAssignment[];\n    _wageChunksByAssignmentId: Record<number, RawWageChunk[]>;\n    _offersByAssignmentId: Record<number, RawOffer[]>;\n}\nconst initialState: AssignmentState = {\n    _modelData: [],\n    // Since we don't want to fetch all wage chunks all the time,\n    // we fetch them on a per-assignment basis and store them here.\n    _wageChunksByAssignmentId: {},\n    _offersByAssignmentId: {},\n};\n\n// basicReducers is an object whose keys are FETCH_SESSIONS_SUCCESS, etc,\n// and values are the corresponding reducer functions\nconst basicReducers = createBasicReducerObject<RawAssignment>(\n    FETCH_ASSIGNMENTS_SUCCESS,\n    FETCH_ONE_ASSIGNMENT_SUCCESS,\n    UPSERT_ONE_ASSIGNMENT_SUCCESS,\n    DELETE_ONE_ASSIGNMENT_SUCCESS\n);\n\n/**\n * Given a list of all the wage chunks for a particular assignment,\n * sets the _wageChunksByAssignmentId hash appropriately.\n *\n * @param {*} state\n * @param {{payload: object}} action\n * @returns\n */\nfunction setWageChunks(\n    state: AssignmentState,\n    action: HasPayload<RawWageChunk[]>\n): AssignmentState {\n    const assignmentId = (action.payload[0] || {}).assignment_id;\n    if (!assignmentId) {\n        return state;\n    }\n    return {\n        ...state,\n        _wageChunksByAssignmentId: {\n            ...state._wageChunksByAssignmentId,\n            [assignmentId]: action.payload,\n        },\n    };\n}\n\n/**\n * Given a list of all offers for a particular assignment,\n * sets the _offersByAssignmentId hash appropriately.\n *\n * @param {*} state\n * @param {{payload: object}} action\n * @returns\n */\nfunction setOffers(\n    state: AssignmentState,\n    action: HasPayload<{ assignment_id: number; offers: RawOffer[] }>\n): AssignmentState {\n    const assignmentId = action.payload.assignment_id;\n    if (!assignmentId) {\n        return state;\n    }\n    return {\n        ...state,\n        _offersByAssignmentId: {\n            ...state._offersByAssignmentId,\n            [assignmentId]: action.payload.offers,\n        },\n    };\n}\n\nexport const assignmentsReducer = createReducer(initialState, {\n    ...basicReducers,\n    // wage chunks are closely associated with assignments, so their actions happen\n    // here\n    [FETCH_WAGE_CHUNKS_FOR_ASSIGNMENT_SUCCESS]: setWageChunks,\n    [UPSERT_WAGE_CHUNKS_FOR_ASSIGNMENT_SUCCESS]: setWageChunks,\n    [FETCH_OFFERS_FOR_ASSIGNMENT_SUCCESS]: setOffers,\n    [UPSERT_OFFERS_FOR_ASSIGNMENT_SUCCESS]: setOffers,\n});\n","import {\n    FETCH_SESSIONS_SUCCESS,\n    FETCH_ONE_SESSION_SUCCESS,\n    UPSERT_ONE_SESSION_SUCCESS,\n    DELETE_ONE_SESSION_SUCCESS,\n    SET_ACTIVE_SESSION,\n} from \"../constants\";\nimport { createBasicReducerObject, createReducer } from \"./utils\";\nimport type { BasicState, HasPayload } from \"./utils\";\nimport { RawSession } from \"../defs/types\";\n\nexport type SessionState = BasicState<RawSession> & {\n    activeSession: RawSession | null;\n};\nconst initialState: SessionState = {\n    _modelData: [] as RawSession[],\n    activeSession: null,\n};\n\n// basicReducers is an object whose keys are FETCH_SESSIONS_SUCCESS, etc,\n// and values are the corresponding reducer functions\nconst basicReducers = createBasicReducerObject(\n    FETCH_SESSIONS_SUCCESS,\n    FETCH_ONE_SESSION_SUCCESS,\n    UPSERT_ONE_SESSION_SUCCESS,\n    DELETE_ONE_SESSION_SUCCESS\n);\n\nexport const sessionsReducer = createReducer<SessionState>(initialState, {\n    ...basicReducers,\n    [SET_ACTIVE_SESSION]: (\n        state: SessionState,\n        action: HasPayload<RawSession>\n    ): SessionState => ({\n        ...state,\n        activeSession: action.payload,\n    }),\n});\n","import {\n    FETCH_POSITIONS_SUCCESS,\n    FETCH_ONE_POSITION_SUCCESS,\n    UPSERT_ONE_POSITION_SUCCESS,\n    DELETE_ONE_POSITION_SUCCESS,\n} from \"../constants\";\nimport { RawPosition } from \"../defs/types\";\nimport { createBasicReducerObject, createReducer } from \"./utils\";\n\ninterface PositionState {\n    _modelData: RawPosition[];\n}\nconst initialState: PositionState = {\n    _modelData: [],\n};\n\n// basicReducers is an object whose keys are FETCH_SESSIONS_SUCCESS, etc,\n// and values are the corresponding reducer functions\nconst basicReducers = createBasicReducerObject<RawPosition>(\n    FETCH_POSITIONS_SUCCESS,\n    FETCH_ONE_POSITION_SUCCESS,\n    UPSERT_ONE_POSITION_SUCCESS,\n    DELETE_ONE_POSITION_SUCCESS\n);\n\nexport const positionsReducer = createReducer(initialState, basicReducers);\n","import {\n    FETCH_INSTRUCTORS_SUCCESS,\n    FETCH_ONE_INSTRUCTOR_SUCCESS,\n    UPSERT_ONE_INSTRUCTOR_SUCCESS,\n    DELETE_ONE_INSTRUCTOR_SUCCESS,\n} from \"../constants\";\nimport { RawInstructor } from \"../defs/types\";\nimport { createBasicReducerObject, createReducer } from \"./utils\";\n\ninterface InstructorState {\n    _modelData: RawInstructor[];\n}\nconst initialState: InstructorState = {\n    _modelData: [],\n};\n\n// basicReducers is an object whose keys are FETCH_SESSIONS_SUCCESS, etc,\n// and values are the corresponding reducer functions\nconst basicReducers = createBasicReducerObject<RawInstructor>(\n    FETCH_INSTRUCTORS_SUCCESS,\n    FETCH_ONE_INSTRUCTOR_SUCCESS,\n    UPSERT_ONE_INSTRUCTOR_SUCCESS,\n    DELETE_ONE_INSTRUCTOR_SUCCESS\n);\n\nexport const instructorsReducer = createReducer(initialState, basicReducers);\n","import {\n    FETCH_APPLICANTS_SUCCESS,\n    FETCH_ONE_APPLICANT_SUCCESS,\n    UPSERT_ONE_APPLICANT_SUCCESS,\n    DELETE_ONE_APPLICANT_SUCCESS,\n} from \"../constants\";\nimport { RawApplicant } from \"../defs/types\";\nimport { createBasicReducerObject, createReducer } from \"./utils\";\n\nexport interface ApplicantsState {\n    _modelData: RawApplicant[];\n}\nconst initialState: ApplicantsState = {\n    _modelData: [],\n};\n\n// basicReducers is an object whose keys are FETCH_SESSIONS_SUCCESS, etc,\n// and values are the corresponding reducer functions\nconst basicReducers = createBasicReducerObject<RawApplicant>(\n    FETCH_APPLICANTS_SUCCESS,\n    FETCH_ONE_APPLICANT_SUCCESS,\n    UPSERT_ONE_APPLICANT_SUCCESS,\n    DELETE_ONE_APPLICANT_SUCCESS\n);\n\nexport const applicantsReducer = createReducer(initialState, basicReducers);\n","import {\n    FETCH_CONTRACT_TEMPLATES_SUCCESS,\n    FETCH_ONE_CONTRACT_TEMPLATE_SUCCESS,\n    UPSERT_ONE_CONTRACT_TEMPLATE_SUCCESS,\n    DELETE_ONE_CONTRACT_TEMPLATE_SUCCESS,\n    FETCH_ALL_CONTRACT_TEMPLATES_SUCCESS,\n} from \"../constants\";\nimport { RawContractTemplate } from \"../defs/types\";\nimport { createBasicReducerObject, createReducer, HasPayload } from \"./utils\";\n\ninterface ContractTemplateState {\n    _modelData: RawContractTemplate[];\n    all: { template_file: string }[];\n}\n\nconst initialState: ContractTemplateState = {\n    _modelData: [],\n    all: [],\n};\n\n// basicReducers is an object whose keys are FETCH_*_SUCCESS, etc,\n// and values are the corresponding reducer functions\nconst basicReducers = createBasicReducerObject<RawContractTemplate>(\n    FETCH_CONTRACT_TEMPLATES_SUCCESS,\n    FETCH_ONE_CONTRACT_TEMPLATE_SUCCESS,\n    UPSERT_ONE_CONTRACT_TEMPLATE_SUCCESS,\n    DELETE_ONE_CONTRACT_TEMPLATE_SUCCESS\n);\n\nexport const contractTemplatesReducer = createReducer(initialState, {\n    ...basicReducers,\n    [FETCH_ALL_CONTRACT_TEMPLATES_SUCCESS]: (\n        state,\n        action: HasPayload<{ template_file: string }[]>\n    ) => ({\n        ...state,\n        all: action.payload,\n    }),\n});\n","import {\n    FETCH_POSTINGS_SUCCESS,\n    FETCH_ONE_POSTING_SUCCESS,\n    UPSERT_ONE_POSTING_SUCCESS,\n    DELETE_ONE_POSTING_SUCCESS,\n} from \"../constants\";\nimport { RawPosting } from \"../defs/types\";\nimport { createBasicReducerObject, createReducer } from \"./utils\";\n\ninterface PostingState {\n    _modelData: RawPosting[];\n}\nconst initialState: PostingState = {\n    _modelData: [],\n};\n\n// basicReducers is an object whose keys are FETCH_SESSIONS_SUCCESS, etc,\n// and values are the corresponding reducer functions\nconst basicReducers = createBasicReducerObject<RawPosting>(\n    FETCH_POSTINGS_SUCCESS,\n    FETCH_ONE_POSTING_SUCCESS,\n    UPSERT_ONE_POSTING_SUCCESS,\n    DELETE_ONE_POSTING_SUCCESS\n);\n\nexport const postingsReducer = createReducer(initialState, basicReducers);\n","import {\n    FETCH_POSTING_POSITIONS_SUCCESS,\n    FETCH_ONE_POSTING_POSITION_SUCCESS,\n    UPSERT_ONE_POSTING_POSITION_SUCCESS,\n    DELETE_ONE_POSTING_POSITION_SUCCESS,\n} from \"../constants\";\nimport { RawPostingPosition } from \"../defs/types\";\nimport { createReducer, HasPayload } from \"./utils\";\n\ninterface PositionPostingState {\n    _modelData: RawPostingPosition[];\n}\nconst initialState: PositionPostingState = {\n    _modelData: [],\n};\n\nexport function upsertItem(\n    modelData: RawPostingPosition[],\n    newItem: RawPostingPosition\n): RawPostingPosition[] {\n    let didUpdate = false;\n    const newModelData = modelData.map((item) => {\n        if (\n            item.position_id === newItem.position_id &&\n            item.posting_id === newItem.posting_id\n        ) {\n            didUpdate = true;\n            return newItem;\n        }\n        return item;\n    });\n    if (!didUpdate) {\n        newModelData.push(newItem);\n    }\n    return newModelData;\n}\n\n// PositionPostings have no `id` field, but they are uniquely determined\n// by their `position_id` adn `posting_id`. So, we need to create custom\n// reducer functions.\nexport const postingPositionsReducer = createReducer(initialState, {\n    [FETCH_POSTING_POSITIONS_SUCCESS]: (\n        state: PositionPostingState,\n        action: HasPayload<RawPostingPosition[]>\n    ) => ({\n        ...state,\n        _modelData: action.payload,\n    }),\n    [FETCH_ONE_POSTING_POSITION_SUCCESS]: (\n        state: PositionPostingState,\n        action: HasPayload<RawPostingPosition>\n    ) => ({\n        ...state,\n        _modelData: upsertItem(state._modelData, action.payload),\n    }),\n    [UPSERT_ONE_POSTING_POSITION_SUCCESS]: (\n        state: PositionPostingState,\n        action: HasPayload<RawPostingPosition>\n    ) => ({\n        ...state,\n        _modelData: upsertItem(state._modelData, action.payload),\n    }),\n    [DELETE_ONE_POSTING_POSITION_SUCCESS]: (\n        state: PositionPostingState,\n        action: HasPayload<RawPostingPosition>\n    ) => {\n        const deletedItem = action.payload;\n        return {\n            ...state,\n            _modelData: state._modelData.filter(\n                (item) =>\n                    !(\n                        item.position_id === deletedItem.position_id &&\n                        item.posting_id === deletedItem.posting_id\n                    )\n            ),\n        };\n    },\n});\n","import {\n    FETCH_USERS_SUCCESS,\n    FETCH_ACTIVE_USER_SUCCESS,\n    SET_ACTIVE_USER_ROLE_SUCCESS,\n} from \"../constants\";\nimport type { ActiveUser, User, UserRole } from \"../defs/types\";\nimport { createReducer } from \"./utils\";\n\nexport interface UsersState {\n    users: User[];\n    active_user: ActiveUser | {};\n    active_role: UserRole | null;\n}\n\nconst initialState: UsersState = {\n    users: [],\n    active_user: {},\n    active_role: null,\n};\n\nexport const usersReducer = createReducer(initialState, {\n    [FETCH_ACTIVE_USER_SUCCESS]: (state, action) => ({\n        ...state,\n        active_user: action.payload,\n    }),\n    [FETCH_USERS_SUCCESS]: (state, action) => ({\n        ...state,\n        users: action.payload,\n    }),\n    [SET_ACTIVE_USER_ROLE_SUCCESS]: (state, action) => ({\n        ...state,\n        active_role: action.payload,\n    }),\n});\n","export const SET_SELECTED_ROWS = \"SET_SELECTED_ROWS\";\n","export const SET_SELECTED_DDAH_TABLE_ROWS = \"SET_SELECTED_DDAH_TABLE_ROWS\";\n","export const SET_SELECTED_POSITION = \"SET_SELECTED_POSITION\";\n","import { SET_SELECTED_ROWS } from \"./constants\";\nimport { createReducer } from \"redux-create-reducer\";\nexport { offerTableReducer };\ninterface OfferTableState {\n    selectedAssignmentIds: number[];\n}\n\n// initialize the state of offer table\nconst initialState: OfferTableState = {\n    selectedAssignmentIds: [],\n};\n\nconst offerTableReducer = createReducer(initialState, {\n    [SET_SELECTED_ROWS]: (state, action) => {\n        return { ...state, selectedAssignmentIds: action.payload };\n    },\n});\n","import { SET_SELECTED_DDAH_TABLE_ROWS } from \"./constants\";\nimport { createReducer } from \"redux-create-reducer\";\nexport { ddahsTableReducer };\n// initialize the state of offer table\nconst initialState = {\n    selectedDdahIds: [] as number[],\n};\n\nconst ddahsTableReducer = createReducer(initialState, {\n    [SET_SELECTED_DDAH_TABLE_ROWS]: (state: any, action: any) => {\n        return { ...state, selectedDdahIds: action.payload };\n    },\n});\n\nexport type DdahsTableType = typeof initialState;\n","import { SET_SELECTED_POSITION } from \"./constants\";\nimport { createReducer } from \"redux-create-reducer\";\nexport { positionsTableReducer };\n\ninterface PositionsTableState {\n    selectedPositionIds: number | null;\n}\n\n// initialize the state of offer table\nconst initialState: PositionsTableState = {\n    selectedPositionIds: null,\n};\n\nconst positionsTableReducer = createReducer(initialState, {\n    [SET_SELECTED_POSITION]: (state, action) => {\n        return { ...state, selectedPositionIds: action.payload };\n    },\n});\n","import {\n    SET_INSTRUCTOR_ACTIVE_POSITION,\n    SET_INSTRUCTOR_DDAHS_FOR_EMAIL,\n} from \"./constants\";\nimport { createReducer } from \"redux-create-reducer\";\nexport { instructorUIReducer };\n\ninterface InstructorUIState {\n    selectedDdahForEmailIds: number[];\n    activePositionId: number | null;\n}\n\n// initialize the state of offer table\nconst initialState: InstructorUIState = {\n    selectedDdahForEmailIds: [],\n    activePositionId: null,\n};\n\nconst instructorUIReducer = createReducer(initialState, {\n    [SET_INSTRUCTOR_DDAHS_FOR_EMAIL]: (state, action) => {\n        return { ...state, selectedDdahForEmailIds: action.payload };\n    },\n    [SET_INSTRUCTOR_ACTIVE_POSITION]: (state, action) => {\n        return { ...state, activePositionId: action.payload };\n    },\n});\n","import {\n    UPSERT_MATCH,\n    BATCH_UPSERT_MATCHES,\n    UPSERT_GUARANTEE,\n    BATCH_UPSERT_GUARANTEES,\n    UPSERT_NOTE,\n    BATCH_UPSERT_NOTES,\n    SET_SELECTED_MATCHING_POSITION,\n    SET_APPLICANT_VIEW_MODE,\n    SET_UPDATED,\n} from \"./constants\";\nimport { createReducer } from \"redux-create-reducer\";\nimport {\n    RawMatch,\n    AppointmentGuaranteeStatus,\n    ApplicantViewMode,\n} from \"./types\";\nexport { matchingDataReducer };\n\nexport interface MatchingDataState {\n    matches: RawMatch[];\n    guarantees: AppointmentGuaranteeStatus[];\n    notes: Record<string, string>;\n    selectedMatchingPositionId: number | null;\n    applicantViewMode: ApplicantViewMode;\n    updated: boolean;\n}\n\nconst initialState: MatchingDataState = {\n    matches: [],\n    guarantees: [],\n    notes: {},\n    selectedMatchingPositionId: null,\n    applicantViewMode: \"grid\",\n    updated: false,\n};\n\nconst matchingDataReducer = createReducer(initialState, {\n    [UPSERT_MATCH]: (state, action) => {\n        // Check if a match with this applicant ID and position ID already exists\n        const existingMatch = state.matches.find(\n            (match) =>\n                match.utorid === action.payload.utorid &&\n                match.positionCode === action.payload.positionCode\n        );\n\n        if (!existingMatch) {\n            const newMatch: RawMatch = {\n                utorid: action.payload.utorid,\n                positionCode: action.payload.positionCode,\n                stagedHoursAssigned: action.payload.stagedHoursAssigned || 0,\n                stagedAssigned: action.payload.stagedAssigned || false,\n                starred: action.payload.starred || false,\n                hidden: action.payload.hidden || false,\n            };\n\n            // If any flag is set to true, add the new RawMatch\n            if (\n                newMatch.stagedAssigned ||\n                newMatch.starred ||\n                newMatch.hidden\n            ) {\n                return {\n                    ...state,\n                    matches: [...state.matches, action.payload],\n                    updated: true,\n                };\n            }\n\n            return state;\n        }\n\n        // Item exists, so we have to update it\n        const newMatch: RawMatch = { ...existingMatch, ...action.payload };\n        return {\n            ...state,\n            matches: state.matches\n                .map((match) => {\n                    if (\n                        match.utorid === action.payload.utorid &&\n                        match.positionCode === action.payload.positionCode\n                    ) {\n                        if (\n                            newMatch.stagedAssigned ||\n                            newMatch.starred ||\n                            newMatch.hidden\n                        ) {\n                            return newMatch;\n                        }\n                        return null;\n                    } else {\n                        return match;\n                    }\n                })\n                .filter((match) => !!match),\n            updated: true,\n        };\n    },\n    [BATCH_UPSERT_MATCHES]: (state, action) => {\n        return { ...state, matches: action.payload };\n    },\n    [UPSERT_GUARANTEE]: (state, action) => {\n        // Check if guarantee for a particular applicant already exists\n        const existingGuarantee = state.guarantees.find(\n            (guarantee) => guarantee.utorid === action.payload.utorid\n        );\n\n        if (!existingGuarantee) {\n            return {\n                ...state,\n                guarantees: [...state.guarantees, action.payload],\n            };\n        }\n\n        // Item exists, update it\n        return {\n            ...state,\n            guarantees: state.guarantees.map((guarantee) => {\n                if (guarantee.utorid === action.payload.utorid) {\n                    return action.payload;\n                } else {\n                    return guarantee;\n                }\n            }),\n            updated: true,\n        };\n    },\n    [BATCH_UPSERT_GUARANTEES]: (state, action) => {\n        return { ...state, guarantees: action.payload, updated: true };\n    },\n    [UPSERT_NOTE]: (state, action) => {\n        const existingNotes: Record<string, string> = { ...state.notes };\n\n        // If the note is empty, delete it from the record\n        if (!action.payload.note) {\n            if (existingNotes[action.payload.utorid]) {\n                delete existingNotes[action.payload.utorid];\n            }\n        } else {\n            existingNotes[action.payload.utorid] = action.payload.note;\n        }\n\n        return { ...state, notes: existingNotes, updated: true };\n    },\n    [BATCH_UPSERT_NOTES]: (state, action) => {\n        return { ...state, notes: action.payload };\n    },\n    [SET_SELECTED_MATCHING_POSITION]: (state, action) => {\n        return { ...state, selectedMatchingPositionId: action.payload };\n    },\n    [SET_APPLICANT_VIEW_MODE]: (state, action) => {\n        return { ...state, applicantViewMode: action.payload };\n    },\n    [SET_UPDATED]: (state, action) => {\n        return { ...state, updated: action.payload };\n    },\n});\n","import { reducer as notificationReducer } from \"react-notification-system-redux\";\nimport { combineReducers } from \"./api/reducers/utils\";\nimport { globalReducer } from \"./api/reducers/globals\";\nimport { offerTableReducer } from \"./views/admin/offertable/reducers\";\nimport {\n    statusReducer,\n    sessionsReducer,\n    positionsReducer,\n    applicantsReducer,\n    applicationsReducer,\n    assignmentsReducer,\n    instructorsReducer,\n    contractTemplatesReducer,\n    ddahsReducer,\n    postingsReducer,\n    postingPositionsReducer,\n} from \"./api/reducers\";\nimport { usersReducer } from \"./api/reducers/users\";\nimport { ddahsTableReducer } from \"./views/admin/ddah-table/reducers\";\nimport { positionsTableReducer } from \"./views/admin/positions/reducers\";\nimport { instructorUIReducer } from \"./views/instructor/store/reducers\";\nimport { instructorPreferencesReducer } from \"./api/reducers/instructorPreferences\";\nimport { matchingDataReducer } from \"./views/admin/matching/reducers\";\n\n// When `combineReducers` is used,\n// every action gets dispatched to every reducer.\n// Since reducers don't change the state on unrecognized\n// actions, this is okay. Further, each reducer believes\n// it has its own top-level state, but in reality it is\n// just passed a part of the whole state. E.g., if `combineReducers`\n// is passed\n//   {\n//      mypath: myReducer\n//   }\n// When `myReducer(localState)` is called, `localState == globalState.mypath`.\nconst reducer = combineReducers({\n    model: combineReducers({\n        status: statusReducer,\n        sessions: sessionsReducer,\n        positions: positionsReducer,\n        applicants: applicantsReducer,\n        applications: applicationsReducer,\n        assignments: assignmentsReducer,\n        instructors: instructorsReducer,\n        contractTemplates: contractTemplatesReducer,\n        postings: postingsReducer,\n        postingPositions: postingPositionsReducer,\n        users: usersReducer,\n        ddahs: ddahsReducer,\n        instructorPreferences: instructorPreferencesReducer,\n    }),\n    ui: combineReducers({\n        notifications: notificationReducer,\n        offerTable: offerTableReducer,\n        ddahsTable: ddahsTableReducer,\n        positionsTable: positionsTableReducer,\n        globals: globalReducer,\n        instructor: instructorUIReducer,\n        matchingData: matchingDataReducer,\n    }),\n});\n\nexport type RootState = ReturnType<typeof reducer>;\nexport default reducer;\n","import { createStore, applyMiddleware } from \"redux\";\nimport { composeWithDevTools } from \"redux-devtools-extension\";\nimport { persistStore, persistReducer } from \"redux-persist\";\nimport storage from \"redux-persist/lib/storage\";\nimport rootReducer from \"./rootReducer\";\nimport thunk from \"redux-thunk\";\n\nconst configureStore = () => {\n    const persistConfig = {\n        key: \"root\",\n        storage,\n        whitelist: [\"auth\", \"application\"],\n    };\n    const persistedReducer = persistReducer(persistConfig, rootReducer);\n    const store = createStore(\n        persistedReducer,\n        composeWithDevTools(applyMiddleware(thunk))\n    );\n    const persistor = persistStore(store);\n\n    if (process.env.NODE_ENV !== \"production\") {\n        if ((module as any).hot) {\n            (module as any).hot.accept(\"./rootReducer\", () => {\n                store.replaceReducer(persistedReducer);\n            });\n        }\n    }\n\n    return { store, persistor };\n};\n\nexport default configureStore;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { Provider } from \"react-redux\";\nimport { HashRouter } from \"react-router-dom\";\nimport { PersistGate } from \"redux-persist/integration/react\";\nimport DynamicEntryRouter from \"./dynamic-entry-router\";\nimport configureStore from \"./store\";\n\nconst { store, persistor } = configureStore();\n\n// In production, we don't want to wrap the app in a dev frame,\n// but we do want to in development\nlet DevFrame = function (props: any) {\n    return <React.Fragment>{props.children}</React.Fragment>;\n};\nif (process.env.REACT_APP_DEV_FEATURES) {\n    // We only want to load the dev frame parts if they are needed,\n    // so we use React.lazy to load them on demand.\n    const FullDevFrame = React.lazy(async () =>\n        import(\"./views/dev_frame\").then((module) => ({\n            // Because `React.lazy` expects a default export, we need to fake\n            // the default export in the case of a named export.\n            default: module.DevFrame,\n        }))\n    );\n    DevFrame = function (props) {\n        return (\n            <React.Suspense fallback=\"Loading...\">\n                <FullDevFrame>{props.children}</FullDevFrame>\n            </React.Suspense>\n        );\n    };\n}\n\nconst render = (Component: React.ElementType) => {\n    return ReactDOM.render(\n        <HashRouter>\n            <Provider store={store}>\n                <PersistGate persistor={persistor}>\n                    <DevFrame>\n                        <div id=\"app-body\">\n                            <Component />\n                        </div>\n                    </DevFrame>\n                </PersistGate>\n            </Provider>\n        </HashRouter>,\n        document.getElementById(\"root\")\n    );\n};\n\nrender(DynamicEntryRouter);\n\n// Hot module reloading\n// https://medium.com/@brianhan/hot-reloading-cra-without-eject-b54af352c642\n\n/*eslint-disable */\nif (\"hot\" in module) {\n    (module as any).hot.accept(\"./dynamic-entry-router\", () => {\n        const NextApp = require(\"./dynamic-entry-router\").default;\n        render(NextApp);\n    });\n}\n/*eslint-enable */\n"],"sourceRoot":""}