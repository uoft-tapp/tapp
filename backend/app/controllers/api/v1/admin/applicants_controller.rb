# frozen_string_literal: true

class Api::V1::Admin::ApplicantsController < ApplicationController
    before_action :find_applicant, only: %i[show delete]

    # GET /applicants
    def index
        if params[:session_id].blank?
            render_success Applicant.order(:id)
            return
        end
        render_success Applicant.by_session(params[:session_id])
    end

    def show
        render_success @applicant
    end

    # POST /applicants/delete
    def delete
        render_on_condition(
            object: @applicant,
            condition: proc { @applicant.destroy! },
            error_message:
                "Could not delete applicant '#{@applicant.first_name} #{
                    @applicant.last_name
                }'. The applicant may have an associated assignment, which means they cannot be deleted."
        )
    end

    # POST /applicants
    def create
        # We allow upserting of applicants by `id` or by `utorid`. This is to avoid confusing
        # behaviour in the frontend: since we only load applicants associated with a given session
        # the frontend cannot actually tell if an applicant is a duplicate applicant or not.
        # Since `utorid` is assumed to be unique, looking up an applicant by `id` or by `utorid`
        # will allow the same applicant to be "imported" multiple times.
        @applicant =
            Applicant.find_by(
                'id = ? OR utorid = ?',
                params[:id],
                params[:utorid]
            )

        # An Applicant can be upserted two ways. Either directly, or though `/session/:session_id/applicants`.
        # in the second case, we automatically create an application associated with
        # the applicant (if no such application exists). So, check for a valid session first.
        @session = nil
        if params.key?(:session_id)
            @session = Session.find(params[:session_id])
            unless @session
                render_error(
                    message:
                        "Cannot find session with id '#{params[:session_id]}'"
                ) && return
            end

            start_transaction_and_rollback_on_exception do
                if @applicant
                    @applicant.update!(applicant_params)
                else
                    @applicant = Applicant.new(applicant_params)
                    @applicant.save!
                end

                # Now, there must be an applicant; create an application if needed
                create_application_if_missing
                render_success @applicant
            end
        elsif @applicant
            update
        else
            @applicant = Applicant.new(applicant_params)
            render_on_condition(
                object: @applicant,
                condition: proc { @applicant.save! }
            )
        end
    end

    private

    # If `@session` is set, make sure there is
    # an application associated with `@applicant` and
    # `@session`.
    def create_application_if_missing
        return unless @session && @applicant

        if @applicant.applications.where(session_id: @session.id).empty?
            # If we're here, then there is no application associated with the current session
            application =
                Application.new(
                    session_id: @session.id,
                    applicant_id: @applicant.id,
                    comments: '<Autogenerated>'
                )
            application.save!
        end
    end

    def find_applicant
        @applicant = Applicant.find(params[:id])
    end

    def applicant_params
        params.slice(
            :email,
            :first_name,
            :last_name,
            :phone,
            :student_number,
            :utorid
        ).permit!
    end

    def update
        render_on_condition(
            object: @applicant,
            condition: proc { @applicant.update!(applicant_params) }
        )
    end
end
